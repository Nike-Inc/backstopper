package com.nike.backstopper.spring.processor;


import com.nike.backstopper.apierror.ApiError;
import com.nike.backstopper.apierror.ApiErrorValue;
import com.nike.backstopper.apierror.projectspecificinfo.AutoConfiguredProjectApiErrorsBuilder;
import com.nike.backstopper.apierror.projectspecificinfo.ProjectApiErrors;
import com.nike.backstopper.mapper.ApiErrorValidationMessagesMapper;
import com.nike.backstopper.model.AutoGeneratedApiError;
import com.nike.backstopper.service.AutoGeneratedApiErrorService;
import com.nike.backstopper.spring.processor.exception.ProjectApiErrorsBeanPostProcessorException;
import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.core.type.MethodMetadata;

import javax.inject.Named;
import javax.inject.Singleton;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Registers or redefines {@link ProjectApiErrors} bean using {@link AutoGeneratedApiError}s
 * based on {@link ApiErrorValue} to current {@link ApplicationContext}.
 *
 * @author Andrey Tsarenko
 */
@Named
@Singleton
public class ProjectApiErrorsBeanPostProcessor implements BeanFactoryPostProcessor, BeanPostProcessor {

    private final AtomicBoolean autoGeneratedProjectApiErrorsRegistered = new AtomicBoolean(false);
    private final Set<ApiError> autoGeneratedApiErrors;

    /**
     * Initialization, since beans is not yet initialized.
     *
     * @see AutoGeneratedApiErrorService
     * @see ApiErrorValidationMessagesMapper
     */
    ProjectApiErrorsBeanPostProcessor() {
        AutoGeneratedApiErrorService autoGeneratedApiErrorService =
                new AutoGeneratedApiErrorService(new ApiErrorValidationMessagesMapper());

        this.autoGeneratedApiErrors = autoGeneratedApiErrorService.findAutoGeneratedApiErrors();
    }

    /**
     * This is the first phase to register {@link ProjectApiErrors} bean using {@link AutoGeneratedApiError}s
     * if the application context does not contain {@link ProjectApiErrors} bean.
     *
     * @param beanFactory the bean factory used by the application context.
     * @throws ProjectApiErrorsBeanPostProcessorException if the processing failed.
     * @see AutoConfiguredProjectApiErrorsBuilder#buildAutoConfiguredProjectApiErrors(Set)
     */
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        try {

            if (!autoGeneratedApiErrors.isEmpty() && !isProjectApiErrorsBeanExist(beanFactory)) {

                autoGeneratedProjectApiErrorsRegistered.getAndSet(true);
                beanFactory.registerSingleton(AutoConfiguredProjectApiErrorsBuilder.class.getName(),
                        AutoConfiguredProjectApiErrorsBuilder.buildAutoConfiguredProjectApiErrors(autoGeneratedApiErrors));
            }
        } catch (Exception e) {
            throw new ProjectApiErrorsBeanPostProcessorException("Unable to process AutoGeneratedProjectApiErrors: "
                    + e.getMessage(), e);
        }
    }

    /**
     * Empty default implementation.
     *
     * @param bean     a new bean instance.
     * @param beanName a name of the bean.
     * @return the same bean.
     */
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }

    /**
     * This is the second phase to redefine {@link ProjectApiErrors} bean using {@link AutoGeneratedApiError}s
     * if {@link ProjectApiErrorsBeanPostProcessor#postProcessBeanFactory} was skipped.
     * <p>
     * Redefines {@link ProjectApiErrors} by merging
     * {@link AutoGeneratedApiError} to existing {@code ProjectApiErrors#getProjectSpecificApiErrors()}
     *
     * @param bean     the new bean instance.
     * @param beanName the name of the bean.
     * @return the redefined {@link ProjectApiErrors} or the same bean for other types.
     * @throws ProjectApiErrorsBeanPostProcessorException if the processing failed.
     * @see AutoConfiguredProjectApiErrorsBuilder#buildDelegatedProjectApiErrors(ProjectApiErrors, Set)
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        try {

            boolean projectApiErrorsShouldBeDelegated = !autoGeneratedProjectApiErrorsRegistered.get()
                    && !autoGeneratedApiErrors.isEmpty()
                    && bean instanceof ProjectApiErrors;

            if (projectApiErrorsShouldBeDelegated) {
                return AutoConfiguredProjectApiErrorsBuilder.buildDelegatedProjectApiErrors(
                        (ProjectApiErrors) bean, autoGeneratedApiErrors);
            }
            return bean;
        } catch (Exception e) {
            throw new ProjectApiErrorsBeanPostProcessorException("Unable to process DelegatedProjectApiErrors: "
                    + e.getMessage(), e);
        }
    }

    private boolean isProjectApiErrorsBeanExist(ConfigurableListableBeanFactory beanFactory) {
        boolean projectApiErrorsBeanExist = false;
        for (String beanName : beanFactory.getBeanDefinitionNames()) {

            if (isProjectApiErrorsBean(beanFactory, beanName)) {
                projectApiErrorsBeanExist = true;
                break;
            }
        }
        return projectApiErrorsBeanExist;
    }

    private boolean isProjectApiErrorsBean(ConfigurableListableBeanFactory beanFactory, String beanName) {
        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
        // gets the name of the bean that is defined as a component by @Component, ... annotations.
        String beanClassName = beanDefinition.getBeanClassName();

        if (beanClassName == null && beanDefinition instanceof AnnotatedBeanDefinition) {

            AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition;
            MethodMetadata factoryMethodMetadata = annotatedBeanDefinition.getFactoryMethodMetadata();
            if (factoryMethodMetadata != null) {
                // gets the name of the bean that is configured by @Bean annotation.
                beanClassName = factoryMethodMetadata.getReturnTypeName();
            }
        }

        return ProjectApiErrors.class.getName().equals(beanClassName);
    }

}
