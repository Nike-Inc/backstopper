package com.nike.backstopper.spring.processor;

import com.nike.backstopper.apierror.ApiError;
import com.nike.backstopper.apierror.projectspecificinfo.AutoConfiguredProjectApiErrorsBuilder;
import com.nike.backstopper.apierror.projectspecificinfo.ProjectApiErrors;
import com.nike.backstopper.apierror.projectspecificinfo.ProjectSpecificErrorCodeRange;
import com.nike.backstopper.apierror.sample.SampleProjectApiErrorsBase;
import com.nike.backstopper.model.AutoGeneratedApiError;
import com.nike.backstopper.spring.processor.exception.ProjectApiErrorsBeanPostProcessorException;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.core.type.MethodMetadata;

import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests the functionality of {@link ProjectApiErrorsBeanPostProcessor}.
 *
 * @author Andrey Tsarenko
 */
public class ProjectApiErrorsBeanPostProcessorTest {

    private static final ApiError FIRST_API_ERROR = new AutoGeneratedApiError(
            "messageValue", "errorCodeValue", 400);
    private static final ApiError SECOND_API_ERROR = new AutoGeneratedApiError(
            "secondMessageValue", "secondErrorCodeValue", 401);

    @Test
    public void postProcessBeanFactory() {
        ProjectApiErrorsBeanPostProcessor beanPostProcessor = new ProjectApiErrorsBeanPostProcessor();
        ProjectApiErrors expectedProjectApiErrors = AutoConfiguredProjectApiErrorsBuilder
                .buildAutoConfiguredProjectApiErrors(Collections.singleton(FIRST_API_ERROR));

        ConfigurableListableBeanFactory beanFactory = mock(ConfigurableListableBeanFactory.class);
        BeanDefinition firstBeanDefinition = mock(BeanDefinition.class);
        AnnotatedBeanDefinition secondBeanDefinition = mock(AnnotatedBeanDefinition.class);
        MethodMetadata secondBeanMethodMetadata = mock(MethodMetadata.class);

        when(beanFactory.getBeanDefinitionNames())
                .thenReturn(new String[]{"firstBean", "secondBean"});
        when(beanFactory.getBeanDefinition("firstBean"))
                .thenReturn(firstBeanDefinition);
        when(beanFactory.getBeanDefinition("secondBean"))
                .thenReturn(secondBeanDefinition);
        when(firstBeanDefinition.getBeanClassName())
                .thenReturn("firstBeanClassName");
        when(secondBeanDefinition.getFactoryMethodMetadata())
                .thenReturn(secondBeanMethodMetadata);
        when(secondBeanMethodMetadata.getReturnTypeName())
                .thenReturn("secondBeanClassName");

        beanPostProcessor.postProcessBeanFactory(beanFactory);

        ArgumentCaptor<String> beanNameCapture = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<ProjectApiErrors> projectApiErrorsCapture = ArgumentCaptor.forClass(ProjectApiErrors.class);
        verify(beanFactory).registerSingleton(beanNameCapture.capture(), projectApiErrorsCapture.capture());

        String registeredBeanName = beanNameCapture.getValue();
        ProjectApiErrors registeredProjectApiErrors = projectApiErrorsCapture.getValue();

        assertThat(registeredBeanName).isEqualTo(AutoConfiguredProjectApiErrorsBuilder.class.getName());
        assertThat(registeredProjectApiErrors.getProjectApiErrors())
                .isEqualTo(expectedProjectApiErrors.getProjectApiErrors());

        // skip postProcessAfterInitialization() when autoGeneratedProjectApiErrorsRegistered by postProcessBeanFactory()
        OriginProjectApiErrors originProjectApiErrors = new OriginProjectApiErrors();
        Object processedProjectApiErrors = beanPostProcessor.postProcessAfterInitialization(
                originProjectApiErrors, "beanName");

        assertThat(processedProjectApiErrors).isEqualTo(originProjectApiErrors);
    }

    @Test
    public void postProcessBeforeInitialization() {
        ProjectApiErrorsBeanPostProcessor beanPostProcessor = new ProjectApiErrorsBeanPostProcessor();
        Object bean = new Object();

        Object processedBean = beanPostProcessor.postProcessBeforeInitialization(bean, bean.toString());

        assertThat(processedBean).isEqualTo(bean);
    }

    @Test
    public void postProcessAfterInitialization() {
        ProjectApiErrorsBeanPostProcessor beanPostProcessor = new ProjectApiErrorsBeanPostProcessor();
        OriginProjectApiErrors originProjectApiErrors = new OriginProjectApiErrors();
        ProjectApiErrors expectedProjectApiErrors = AutoConfiguredProjectApiErrorsBuilder.buildDelegatedProjectApiErrors(
                originProjectApiErrors, Collections.singleton(FIRST_API_ERROR));

        ProjectApiErrors processedProjectApiErrors = (ProjectApiErrors) beanPostProcessor.postProcessAfterInitialization(
                originProjectApiErrors, "beanName");

        assertThat(processedProjectApiErrors.getProjectApiErrors())
                .isEqualTo(expectedProjectApiErrors.getProjectApiErrors());
    }

    @Test(expected = ProjectApiErrorsBeanPostProcessorException.class)
    public void postProcessBeanFactoryFailed() {
        ProjectApiErrorsBeanPostProcessor beanPostProcessor = new ProjectApiErrorsBeanPostProcessor();
        ConfigurableListableBeanFactory beanFactory = mock(ConfigurableListableBeanFactory.class);

        when(beanFactory.getBeanDefinitionNames())
                .thenThrow(new RuntimeException("test exception"));

        beanPostProcessor.postProcessBeanFactory(beanFactory);
    }

    @Test(expected = ProjectApiErrorsBeanPostProcessorException.class)
    public void postProcessAfterInitializationFailed() {
        ProjectApiErrorsBeanPostProcessor beanPostProcessor = new ProjectApiErrorsBeanPostProcessor();
        OriginProjectApiErrors originProjectApiErrors = mock(OriginProjectApiErrors.class);

        when(originProjectApiErrors.getProjectSpecificApiErrors())
                .thenThrow(new RuntimeException("test exception"));

        beanPostProcessor.postProcessAfterInitialization(originProjectApiErrors, "beanName");
    }

    private static class OriginProjectApiErrors extends SampleProjectApiErrorsBase {

        @Override
        protected List<ApiError> getProjectSpecificApiErrors() {
            return Collections.singletonList(SECOND_API_ERROR);
        }

        @Override
        protected ProjectSpecificErrorCodeRange getProjectSpecificErrorCodeRange() {
            return ProjectSpecificErrorCodeRange.ALLOW_ALL_ERROR_CODES;
        }

    }

}
